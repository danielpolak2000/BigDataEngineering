---
# Source: crypto-tracker/charts/influxdb2/templates/pdb.yaml
apiVersion: policy/v1
kind: PodDisruptionBudget
metadata:
  name: release-name-influxdb2
  labels:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.7.4"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: influxdb2-2.1.2
spec:
  minAvailable: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: influxdb2
      app.kubernetes.io/instance: release-name
---
# Source: crypto-tracker/charts/influxdb2/templates/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-influxdb2
  labels:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.7.4"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: influxdb2-2.1.2
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-spark-operator-controller
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
---
# Source: crypto-tracker/charts/spark-operator/templates/spark/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-spark-operator-spark
  namespace: crypto-tracker
  labels: 
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/serviceaccount.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: release-name-spark-operator-webhook
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/010-ServiceAccount-strimzi-cluster-operator.yaml
apiVersion: v1
kind: ServiceAccount
metadata:
  name: strimzi-cluster-operator
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: service-account
    release: release-name
    heritage: Helm
---
# Source: crypto-tracker/charts/influxdb2/templates/secret.yaml
apiVersion: v1
kind: Secret
metadata:
  labels:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.7.4"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: influxdb2-2.1.2
  name: release-name-influxdb2-auth
data:
  admin-token: "T0JLNmM1TFAzWkpiQzhXNUoydmk5eU54dHJTdDJWNmc="
  admin-password: "VmNGSUtmZ0xIaTM1MXhKUHdtWDlCUmRqZlJ6VGZDSlE="
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/050-ConfigMap-strimzi-cluster-operator.yaml
kind: ConfigMap
apiVersion: v1
metadata:
  name: strimzi-cluster-operator
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: logging-config-map
    release: release-name
    heritage: Helm
data:
  log4j2.properties: |
    name = COConfig
    monitorInterval = 30

    appender.console.type = Console
    appender.console.name = STDOUT
    appender.console.layout.type = PatternLayout
    appender.console.layout.pattern = %d{yyyy-MM-dd HH:mm:ss} %-5p %c{1}:%L - %m%n

    rootLogger.level = ${env:STRIMZI_LOG_LEVEL:-INFO}
    rootLogger.appenderRefs = stdout
    rootLogger.appenderRef.console.ref = STDOUT

    # Kafka AdminClient logging is a bit noisy at INFO level
    logger.kafka.name = org.apache.kafka
    logger.kafka.level = WARN

    # Zookeeper is very verbose even on INFO level -> We set it to WARN by default
    logger.zookeepertrustmanager.name = org.apache.zookeeper
    logger.zookeepertrustmanager.level = WARN

    # Keeps separate level for Netty logging -> to not be changed by the root logger
    logger.netty.name = io.netty
    logger.netty.level = INFO
---
# Source: crypto-tracker/charts/influxdb2/templates/persistent-volume-claim.yaml
kind: PersistentVolumeClaim
apiVersion: v1
metadata:
  name: "release-name-influxdb2"
  labels:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.7.4"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: influxdb2-2.1.2
  annotations:
    helm.sh/resource-policy: "keep"
spec:
  accessModes:
    - "ReadWriteOnce"
  resources:
    requests:
      storage: "50Gi"
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: release-name-spark-operator-controller
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
rules:
- apiGroups:
  - ""
  resources:
  - nodes
  verbs:
  - get
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - update
  - patch
- apiGroups:
  - apiextensions.k8s.io
  resources:
  - customresourcedefinitions
  verbs:
  - get
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: release-name-spark-operator-webhook
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
rules:
- apiGroups:
  - ""
  resources:
  - events
  verbs:
  - create
  - update
  - patch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  - validatingwebhookconfigurations
  verbs:
  - list
  - watch
- apiGroups:
  - admissionregistration.k8s.io
  resources:
  - mutatingwebhookconfigurations
  - validatingwebhookconfigurations
  resourceNames:
  - release-name-spark-operator-webhook
  verbs:
  - get
  - update
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/020-ClusterRole-strimzi-cluster-operator-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-cluster-operator-namespaced
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role
    release: release-name
    heritage: Helm
rules:
# Resources in this role are used by the operator based on an operand being deployed in some namespace. When needed, you
# can deploy the operator as a cluster-wide operator. But grant the rights listed in this role only on the namespaces
# where the operands will be deployed. That way, you can limit the access the operator has to other namespaces where it
# does not manage any clusters.
- apiGroups:
  - "rbac.authorization.k8s.io"
  resources:
    # The cluster operator needs to access and manage rolebindings to grant Strimzi components cluster permissions
  - rolebindings
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - "rbac.authorization.k8s.io"
  resources:
    # The cluster operator needs to access and manage roles to grant the entity operator permissions
  - roles
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - ""
  resources:
    # The cluster operator needs to access and delete pods, this is to allow it to monitor pod health and coordinate rolling updates
  - pods
    # The cluster operator needs to access and manage service accounts to grant Strimzi components cluster permissions
  - serviceaccounts
    # The cluster operator needs to access and manage config maps for Strimzi components configuration
  - configmaps
    # The cluster operator needs to access and manage services and endpoints to expose Strimzi components to network traffic
  - services
  - endpoints
    # The cluster operator needs to access and manage secrets to handle credentials
  - secrets
    # The cluster operator needs to access and manage persistent volume claims to bind them to Strimzi components for persistent data
  - persistentvolumeclaims
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - "apps"
  resources:
    # The cluster operator needs to access and manage deployments to run deployment based Strimzi components
  - deployments
    # The cluster operator needs to access and manage stateful sets to run stateful sets based Strimzi components
  - statefulsets
    # The cluster operator needs to access replica-sets to manage Strimzi components and to determine error states
  - replicasets
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - "apps"
  resources:
    # The Cluster Operator needs to scale Deployments while migrating Connect and Mirror Maker 2 clusters from Deployments to StrimziPodSets
  - deployments/scale
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - "events.k8s.io" # new events api, used by cluster operator
  resources:
    # The cluster operator needs to be able to create events
  - events
  verbs:
  - create
- apiGroups:
    # Kafka Connect Build on OpenShift requirement
  - build.openshift.io
  resources:
  - buildconfigs
  - buildconfigs/instantiate
  - builds
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - networking.k8s.io
  resources:
    # The cluster operator needs to access and manage network policies to lock down communication between Strimzi components
  - networkpolicies
    # The cluster operator needs to access and manage ingresses which allow external access to the services in a cluster
  - ingresses
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - route.openshift.io
  resources:
    # The cluster operator needs to access and manage routes to expose Strimzi components for external access
  - routes
  - routes/custom-host
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - image.openshift.io
  resources:
  # The cluster operator needs to verify the image stream when used for Kafka Connect image build
  - imagestreams
  verbs:
  - get
- apiGroups:
  - policy
  resources:
    # The cluster operator needs to access and manage pod disruption budgets this limits the number of concurrent disruptions
    # that a Strimzi component experiences, allowing for higher availability
  - poddisruptionbudgets
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/021-ClusterRole-strimzi-cluster-operator-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-cluster-operator-global
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role
    release: release-name
    heritage: Helm
rules:
- apiGroups:
  - "rbac.authorization.k8s.io"
  resources:
    # The cluster operator needs to create and manage cluster role bindings in the case of an install where a user
    # has specified they want their cluster role bindings generated
  - clusterrolebindings
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - storage.k8s.io
  resources:
    # The cluster operator requires "get" permissions to view storage class details
    # This is because only a persistent volume of a supported storage class type can be resized
  - storageclasses
  verbs:
  - get
- apiGroups:
    - ""
  resources:
    # The cluster operator requires "list" permissions to view all nodes in a cluster
    # The listing is used to determine the node addresses when NodePort access is configured
    # These addresses are then exposed in the custom resource states
  - nodes
  verbs:
  - list
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/022-ClusterRole-strimzi-cluster-operator-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-cluster-operator-leader-election
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role
    release: release-name
    heritage: Helm
rules:
- apiGroups:
  - coordination.k8s.io
  resources:
    # The cluster operator needs to access and manage leases for leader election
    # The "create" verb cannot be used with "resourceNames"
  - leases
  verbs:
  - create
- apiGroups:
  - coordination.k8s.io
  resources:
    # The cluster operator needs to access and manage leases for leader election
  - leases
  resourceNames:
    # The default RBAC files give the operator only access to the Lease resource names strimzi-cluster-operator
    # If you want to use another resource name or resource namespace, you have to configure the RBAC resources accordingly
  - strimzi-cluster-operator
  verbs:
  - get
  - list
  - watch
  - delete
  - patch
  - update
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/023-ClusterRole-strimzi-cluster-operator-role.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-cluster-operator-watched
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role
    release: release-name
    heritage: Helm
rules:
# Resources in this role are being watched by the operator. When operator is deployed as cluster-wide, these permissions
# need to be granted to the operator on a cluster wide level as well, even if the operands will be deployed only in
# few of the namespaces in given cluster. This is required to set up the Kubernetes watches and informers.
# Note: The rights included in this role might change in the future
- apiGroups:
  - ""
  resources:
    # The cluster operator needs to access and delete pods, this is to allow it to monitor pod health and coordinate rolling updates
  - pods
  verbs:
  - watch
  - list
- apiGroups:
  - "kafka.strimzi.io"
  resources:
  # The Cluster Operator operates the Strimzi custom resources
  - kafkas
  - kafkanodepools
  - kafkaconnects
  - kafkaconnectors
  - kafkamirrormakers
  - kafkabridges
  - kafkamirrormaker2s
  - kafkarebalances
  verbs:
  - get
  - list
  - watch
  - create
  - patch
  - update
- apiGroups:
  - "kafka.strimzi.io"
  resources:
  # The Cluster Operator needs to manage the status of the Strimzi custom resources
  - kafkas/status
  - kafkanodepools/status
  - kafkaconnects/status
  - kafkaconnectors/status
  - kafkamirrormakers/status
  - kafkabridges/status
  - kafkamirrormaker2s/status
  - kafkarebalances/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - "core.strimzi.io"
  resources:
  # The cluster operator uses StrimziPodSets to manage the Kafka and ZooKeeper pods
  - strimzipodsets
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
- apiGroups:
  - "core.strimzi.io"
  resources:
  # The Cluster Operator needs to manage the status of the StrimziPodSet custom resource
  - strimzipodsets/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
    - "kafka.strimzi.io"
  resources:
    # The Cluster Operator needs deletion for KafkaRebalance only (during auto-rebalancing)
    - kafkarebalances
  verbs:
    - delete
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/030-ClusterRole-strimzi-kafka-broker.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-kafka-broker
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: broker-role
    release: release-name
    heritage: Helm
rules:
- apiGroups:
  - ""
  resources:
    # The Kafka Brokers require "get" permissions to view the node they are on
    # This information is used to generate a Rack ID that is used for High Availability configurations
  - nodes
  verbs:
  - get
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/031-ClusterRole-strimzi-entity-operator.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-entity-operator
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: entity-operator-role
    release: release-name
    heritage: Helm
rules:
- apiGroups:
  - "kafka.strimzi.io"
  resources:
    # The Entity Operator contains the Topic Operator which needs to access and manage KafkaTopic resources
  - kafkatopics
  verbs:
  - get
  - list
  - watch
  - create
  - patch
  - update
  - delete
- apiGroups:
  - "kafka.strimzi.io"
  resources:
    # The Entity Operator contains the User Operator which needs to access and manage KafkaUser resources
  - kafkausers
  verbs:
  - get
  - list
  - watch
  - create
  - patch
  - update
- apiGroups:
  - "kafka.strimzi.io"
  resources:
    # The Entity Operator contains the Topic Operator which needs to access and manage KafkaTopic resources
  - kafkatopics/status
    # The Entity Operator contains the User Operator which needs to access and manage KafkaUser resources
  - kafkausers/status
  verbs:
  - get
  - patch
  - update
- apiGroups:
  - ""
  resources:
    # The entity operator user-operator needs to access and manage secrets to store generated credentials
  - secrets
  verbs:
  - get
  - list
  - watch
  - create
  - delete
  - patch
  - update
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/033-ClusterRole-strimzi-kafka-client.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: strimzi-kafka-client
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: client-role
    release: release-name
    heritage: Helm
rules:
- apiGroups:
  - ""
  resources:
    # The Kafka clients (Connect, Mirror Maker, etc.) require "get" permissions to view the node they are on
    # This information is used to generate a Rack ID (client.rack option) that is used for consuming from the closest
    # replicas when enabled
  - nodes
  verbs:
  - get
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: release-name-spark-operator-controller
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-controller
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: release-name-spark-operator-controller
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: release-name-spark-operator-webhook
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-webhook
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: release-name-spark-operator-webhook
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/021-ClusterRoleBinding-strimzi-cluster-operator.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: strimzi-cluster-operator
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role-binding
    release: release-name
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-cluster-operator-global
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/030-ClusterRoleBinding-strimzi-cluster-operator-kafka-broker-delegation.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: strimzi-cluster-operator-kafka-broker-delegation
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: broker-role-binding
    release: release-name
    heritage: Helm
# The Kafka broker cluster role must be bound to the cluster operator service account so that it can delegate the cluster role to the Kafka brokers.
# This must be done to avoid escalating privileges which would be blocked by Kubernetes.
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-kafka-broker
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/033-ClusterRoleBinding-strimzi-cluster-operator-kafka-client-delegation.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: strimzi-cluster-operator-kafka-client-delegation
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: client-role-binding
    release: release-name
    heritage: Helm
# The Kafka clients cluster role must be bound to the cluster operator service account so that it can delegate the
# cluster role to the Kafka clients using it for consuming from closest replica.
# This must be done to avoid escalating privileges which would be blocked by Kubernetes.
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-kafka-client
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: release-name-spark-operator-controller
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
rules:
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  resourceNames:
  - release-name-spark-operator-controller-lock
  verbs:
  - get
  - update
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: release-name-spark-operator-controller
  namespace: crypto-tracker
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
  - deletecollection
- apiGroups:
  - ""
  resources:
  - configmaps
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - persistentvolumeclaims
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - ""
  resources:
  - services
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - extensions
  - networking.k8s.io
  resources:
  - ingresses
  verbs:
  - get
  - create
  - delete
- apiGroups:
  - sparkoperator.k8s.io
  resources:
  - sparkapplications
  - scheduledsparkapplications
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
- apiGroups:
  - sparkoperator.k8s.io
  resources:
  - sparkapplications/status
  - sparkapplications/finalizers
  - scheduledsparkapplications/status
  - scheduledsparkapplications/finalizers
  verbs:
  - get
  - update
  - patch
---
# Source: crypto-tracker/charts/spark-operator/templates/spark/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: release-name-spark-operator-spark
  namespace: crypto-tracker
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
rules:
- apiGroups:
  - ""
  resources:
  - pods
  - configmaps
  - persistentvolumeclaims
  - services
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
  - deletecollection
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: release-name-spark-operator-webhook
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
rules:
- apiGroups:
  - ""
  resources:
  - secrets
  verbs:
  - create
- apiGroups:
  - ""
  resources:
  - secrets
  resourceNames:
  - release-name-spark-operator-webhook-certs
  verbs:
  - get
  - update
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  verbs:
  - create
- apiGroups:
  - coordination.k8s.io
  resources:
  - leases
  resourceNames:
  - release-name-spark-operator-webhook-lock
  verbs:
  - get
  - update
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: Role
metadata:
  name: release-name-spark-operator-webhook
  namespace: crypto-tracker
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
rules:
- apiGroups:
  - ""
  resources:
  - pods
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - ""
  resources:
  - resourcequotas
  verbs:
  - get
  - list
  - watch
- apiGroups:
  - sparkoperator.k8s.io
  resources:
  - sparkapplications
  - sparkapplications/status
  - sparkapplications/finalizers
  - scheduledsparkapplications
  - scheduledsparkapplications/status
  - scheduledsparkapplications/finalizers
  verbs:
  - get
  - list
  - watch
  - create
  - update
  - patch
  - delete
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: release-name-spark-operator-controller
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-controller
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-spark-operator-controller
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: release-name-spark-operator-controller
  namespace: crypto-tracker
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-controller
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-spark-operator-controller
---
# Source: crypto-tracker/charts/spark-operator/templates/spark/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: release-name-spark-operator-spark
  namespace: crypto-tracker
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-spark
  namespace: crypto-tracker
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-spark-operator-spark
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: release-name-spark-operator-webhook
  namespace: default
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-webhook
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-spark-operator-webhook
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/rbac.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: release-name-spark-operator-webhook
  namespace: crypto-tracker
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
subjects:
- kind: ServiceAccount
  name: release-name-spark-operator-webhook
  namespace: default
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: Role
  name: release-name-spark-operator-webhook
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/020-RoleBinding-strimzi-cluster-operator.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: strimzi-cluster-operator
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role-binding
    release: release-name
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-cluster-operator-namespaced
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/022-RoleBinding-strimzi-cluster-operator.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: strimzi-cluster-operator-leader-election
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role-binding
    release: release-name
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-cluster-operator-leader-election
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/023-RoleBinding-strimzi-cluster-operator.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: strimzi-cluster-operator-watched
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: role-binding
    release: release-name
    heritage: Helm
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-cluster-operator-watched
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/031-RoleBinding-strimzi-cluster-operator-entity-operator-delegation.yaml
apiVersion: rbac.authorization.k8s.io/v1
kind: RoleBinding
metadata:
  name: strimzi-cluster-operator-entity-operator-delegation
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: entity-operator-role-binding
    release: release-name
    heritage: Helm
# The Entity Operator cluster role must be bound to the cluster operator service account so that it can delegate the cluster role to the Entity Operator.
# This must be done to avoid escalating privileges which would be blocked by Kubernetes.
subjects:
  - kind: ServiceAccount
    name: strimzi-cluster-operator
    namespace: default
roleRef:
  kind: ClusterRole
  name: strimzi-entity-operator
  apiGroup: rbac.authorization.k8s.io
---
# Source: crypto-tracker/charts/influxdb2/templates/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-influxdb2
  labels:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.7.4"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: influxdb2-2.1.2
spec:
  type: ClusterIP
  ports:
    - name: http
      port: 80
      protocol: TCP
      targetPort: 8086
  selector:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/service.yaml
apiVersion: v1
kind: Service
metadata:
  name: release-name-spark-operator-webhook-svc
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
spec:
  selector:
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/component: webhook
  ports:
  - port: 9443
    targetPort: "webhook"
    name: webhook
---
# Source: crypto-tracker/charts/spark-operator/templates/controller/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-spark-operator-controller
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: controller
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: spark-operator
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: controller
  template:
    metadata:
      labels:
        app.kubernetes.io/name: spark-operator
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/component: controller
      annotations:
        prometheus.io/scrape: "true"
        prometheus.io/port: "8080"
        prometheus.io/path: /metrics
    spec:
      containers:
      - name: spark-operator-controller
        image: docker.io/kubeflow/spark-operator:2.0.2
        imagePullPolicy: IfNotPresent
        args:
        - controller
        - start
        - --zap-log-level=info
        - --namespaces=crypto-tracker
        - --controller-threads=5
        - --enable-ui-service=true
        - --enable-metrics=true
        - --metrics-bind-address=:8080
        - --metrics-endpoint=/metrics
        - --metrics-prefix=
        - --metrics-labels=app_type
        - --leader-election=true
        - --leader-election-lock-name=release-name-spark-operator-controller-lock
        - --leader-election-lock-namespace=default
        - --workqueue-ratelimiter-bucket-qps=50
        - --workqueue-ratelimiter-bucket-size=500
        - --workqueue-ratelimiter-max-delay=6h
        ports:
        - name: "metrics"
          containerPort: 8080
        livenessProbe:
          httpGet:
            port: 8081
            scheme: HTTP
            path: /healthz
        readinessProbe:
          httpGet:
            port: 8081
            scheme: HTTP
            path: /readyz
      serviceAccountName: release-name-spark-operator-controller
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: release-name-spark-operator-webhook
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: spark-operator
      app.kubernetes.io/instance: release-name
      app.kubernetes.io/component: webhook
  template:
    metadata:
      labels:
        app.kubernetes.io/name: spark-operator
        app.kubernetes.io/instance: release-name
        app.kubernetes.io/component: webhook
    spec:
      containers:
      - name: spark-operator-webhook
        image: docker.io/kubeflow/spark-operator:2.0.2
        imagePullPolicy: IfNotPresent
        args:
        - webhook
        - start
        - --zap-log-level=info
        - --namespaces=crypto-tracker
        - --webhook-secret-name=release-name-spark-operator-webhook-certs
        - --webhook-secret-namespace=default
        - --webhook-svc-name=release-name-spark-operator-webhook-svc
        - --webhook-svc-namespace=default
        - --webhook-port=9443
        - --mutating-webhook-name=release-name-spark-operator-webhook
        - --validating-webhook-name=release-name-spark-operator-webhook
        - --enable-metrics=true
        - --metrics-bind-address=:8080
        - --metrics-endpoint=/metrics
        - --metrics-prefix=
        - --metrics-labels=app_type
        - --leader-election=true
        - --leader-election-lock-name=release-name-spark-operator-webhook-lock
        - --leader-election-lock-namespace=default
        ports:
        - name: "webhook"
          containerPort: 9443
        - name: "metrics"
          containerPort: 8080
        livenessProbe:
          httpGet:
            port: 8081
            scheme: HTTP
            path: /healthz
        readinessProbe:
          httpGet:
            port: 8081
            scheme: HTTP
            path: /readyz
      serviceAccountName: release-name-spark-operator-webhook
---
# Source: crypto-tracker/charts/strimzi-kafka-operator/templates/060-Deployment-strimzi-cluster-operator.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: strimzi-cluster-operator
  namespace: default
  labels:
    app: strimzi
    chart: strimzi-kafka-operator-0.44.0
    component: deployment
    release: release-name
    heritage: Helm
spec:
  replicas: 1
  selector:
    matchLabels:
      name: strimzi-cluster-operator
      strimzi.io/kind: cluster-operator
  template:
    metadata:
      labels:
        name: strimzi-cluster-operator
        strimzi.io/kind: cluster-operator
    spec:
      serviceAccountName: strimzi-cluster-operator
      volumes:
        - name: strimzi-tmp
          emptyDir:
            medium: Memory
            sizeLimit: 1Mi
        - name: co-config-volume
          configMap:
            name: strimzi-cluster-operator
      containers:
        - name: strimzi-cluster-operator
          image: quay.io/strimzi/operator:0.44.0
          ports:
            - containerPort: 8080
              name: http
          args:
            - /opt/strimzi/bin/cluster_operator_run.sh
          volumeMounts:
            - name: strimzi-tmp
              mountPath: /tmp
            - name: co-config-volume
              mountPath: /opt/strimzi/custom-config/
          env:
            - name: STRIMZI_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: STRIMZI_FULL_RECONCILIATION_INTERVAL_MS
              value: "120000"
            - name: STRIMZI_OPERATION_TIMEOUT_MS
              value: "300000"
            - name: STRIMZI_DEFAULT_KAFKA_EXPORTER_IMAGE
              value: quay.io/strimzi/kafka:0.44.0-kafka-3.8.0
            - name: STRIMZI_DEFAULT_CRUISE_CONTROL_IMAGE
              value: quay.io/strimzi/kafka:0.44.0-kafka-3.8.0
            - name: STRIMZI_KAFKA_IMAGES
              value: |                 
                3.7.0=quay.io/strimzi/kafka:0.44.0-kafka-3.7.0
                3.7.1=quay.io/strimzi/kafka:0.44.0-kafka-3.7.1
                3.8.0=quay.io/strimzi/kafka:0.44.0-kafka-3.8.0
            - name: STRIMZI_KAFKA_CONNECT_IMAGES
              value: |                 
                3.7.0=quay.io/strimzi/kafka:0.44.0-kafka-3.7.0
                3.7.1=quay.io/strimzi/kafka:0.44.0-kafka-3.7.1
                3.8.0=quay.io/strimzi/kafka:0.44.0-kafka-3.8.0
            - name: STRIMZI_KAFKA_MIRROR_MAKER_IMAGES
              value: |                 
                3.7.0=quay.io/strimzi/kafka:0.44.0-kafka-3.7.0
                3.7.1=quay.io/strimzi/kafka:0.44.0-kafka-3.7.1
                3.8.0=quay.io/strimzi/kafka:0.44.0-kafka-3.8.0
            - name: STRIMZI_KAFKA_MIRROR_MAKER_2_IMAGES
              value: |                 
                3.7.0=quay.io/strimzi/kafka:0.44.0-kafka-3.7.0
                3.7.1=quay.io/strimzi/kafka:0.44.0-kafka-3.7.1
                3.8.0=quay.io/strimzi/kafka:0.44.0-kafka-3.8.0
            - name: STRIMZI_DEFAULT_TOPIC_OPERATOR_IMAGE
              value: quay.io/strimzi/operator:0.44.0
            - name: STRIMZI_DEFAULT_USER_OPERATOR_IMAGE
              value: quay.io/strimzi/operator:0.44.0
            - name: STRIMZI_DEFAULT_KAFKA_INIT_IMAGE
              value: quay.io/strimzi/operator:0.44.0
            - name: STRIMZI_DEFAULT_KAFKA_BRIDGE_IMAGE
              value: quay.io/strimzi/kafka-bridge:0.30.0
            - name: STRIMZI_DEFAULT_KANIKO_EXECUTOR_IMAGE
              value: quay.io/strimzi/kaniko-executor:0.44.0
            - name: STRIMZI_DEFAULT_MAVEN_BUILDER
              value: quay.io/strimzi/maven-builder:0.44.0
            - name: STRIMZI_OPERATOR_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            
            - name: STRIMZI_FEATURE_GATES
              value: ""
            - name: STRIMZI_LEADER_ELECTION_ENABLED
              value: "true"
            - name: STRIMZI_LEADER_ELECTION_LEASE_NAME
              value: "strimzi-cluster-operator"
            - name: STRIMZI_LEADER_ELECTION_LEASE_NAMESPACE
              valueFrom:
                fieldRef:
                  fieldPath: metadata.namespace
            - name: STRIMZI_LEADER_ELECTION_IDENTITY
              valueFrom:
                fieldRef:
                  fieldPath: metadata.name
          livenessProbe:
            httpGet:
              path: /healthy
              port: http
            initialDelaySeconds: 10
            periodSeconds: 30
          readinessProbe:
            httpGet:
              path: /ready
              port: http
            initialDelaySeconds: 10
            periodSeconds: 30
          resources:
            limits:
              cpu: 1000m
              memory: 384Mi
            requests:
              cpu: 200m
              memory: 384Mi
---
# Source: crypto-tracker/charts/influxdb2/templates/statefulset.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: release-name-influxdb2
  labels:
    app.kubernetes.io/name: influxdb2
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.7.4"
    app.kubernetes.io/managed-by: Helm
    helm.sh/chart: influxdb2-2.1.2
spec:
  replicas: 1
  selector:
    matchLabels:
      app.kubernetes.io/name: influxdb2
      app.kubernetes.io/instance: release-name
  serviceName: "release-name-influxdb2"
  template:
    metadata:
      labels:
        app.kubernetes.io/name: influxdb2
        app.kubernetes.io/instance: release-name
    spec:
      volumes:
        - name: data
          persistentVolumeClaim:
            claimName: release-name-influxdb2
      serviceAccountName: release-name-influxdb2
      containers:
        - name: influxdb2
          image: "influxdb:2.7.4-alpine"
          imagePullPolicy: IfNotPresent
          ports:
            - name: http
              containerPort: 8086
              protocol: TCP
          env:
            # Automated setup will not run if an existing boltdb file is found at the configured path.
            # This behavior allows for the InfluxDB container to reboot post-setup without encountering "DB is already set up" errors.
            - name: DOCKER_INFLUXDB_INIT_MODE
              value: setup
            # The username to set for the system's initial super-user (Required).
            - name: DOCKER_INFLUXDB_INIT_USERNAME
              value: admin
            # The password to set for the system's inital super-user (Required).
            - name: DOCKER_INFLUXDB_INIT_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: release-name-influxdb2-auth
                  key: admin-password
            # The name to set for the system's initial organization (Required).
            - name: DOCKER_INFLUXDB_INIT_ORG
              value: influxdata
            # The name to set for the system's initial bucket (Required).
            - name: DOCKER_INFLUXDB_INIT_BUCKET
              value: default
            # The duration the system's initial bucket should retain data. If not set, the initial bucket will retain data forever.
            - name: DOCKER_INFLUXDB_INIT_RETENTION
              value: 0s
            # The authentication token to associate with the system's initial super-user. If not set, a token will be auto-generated by the system.
            - name: DOCKER_INFLUXDB_INIT_ADMIN_TOKEN
              valueFrom:
                secretKeyRef:
                  name: release-name-influxdb2-auth
                  key: admin-token
            # Path to the BoltDB database.
            - name: INFLUXD_BOLT_PATH
              value: /var/lib/influxdb2/influxd.bolt
            # Path to persistent storage engine files where InfluxDB stores all Time-Structure Merge Tree (TSM) data on disk.
            - name: INFLUXD_ENGINE_PATH
              value: /var/lib/influxdb2
          livenessProbe:
            httpGet:
              path: /health
              port: http
              scheme: HTTP
            initialDelaySeconds: 0
            periodSeconds: 10
            timeoutSeconds: 1
            failureThreshold: 3
          readinessProbe:
            httpGet:
              path: /health
              port: http
              scheme: HTTP
            initialDelaySeconds: 0
            periodSeconds: 10
            timeoutSeconds: 1
            successThreshold: 1
            failureThreshold: 3
          volumeMounts:
          - name: data
            mountPath: /var/lib/influxdb2
            subPath: 
          resources:
            {}
---
# Source: crypto-tracker/templates/kafka-cluster-deployment.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: Kafka
metadata:
  name: kafka-cluster
spec:
  kafka:
    version: 3.8.0
    replicas: 1
    listeners:
      - name: plain
        port: 9092
        type: internal
        tls: false
      - name: tls
        port: 9093
        type: internal
        tls: true
    config:
      offsets.topic.replication.factor: 1
      transaction.state.log.replication.factor: 1
      transaction.state.log.min.isr: 1
      default.replication.factor: 1
      min.insync.replicas: 1
      inter.broker.protocol.version: "3.8"
    storage:
      type: ephemeral
  zookeeper:
    replicas: 3
    storage:
      type: ephemeral
  entityOperator:
    topicOperator: {}
    userOperator: {}
---
# Source: crypto-tracker/templates/kafka-topic.yaml
apiVersion: kafka.strimzi.io/v1beta2
kind: KafkaTopic
metadata:
  name: crypto-data
  labels:
    strimzi.io/cluster: kafka-cluster
spec:
  partitions: 1
  replicas: 1
  config:
    retention.ms: 7200000
    segment.bytes: 1073741824
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/mutatingwebhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: MutatingWebhookConfiguration
metadata:
  name: release-name-spark-operator-webhook
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
webhooks:
- name: mutate--v1-pod.sparkoperator.k8s.io
  admissionReviewVersions: ["v1"]
  clientConfig:
    service:
      name: release-name-spark-operator-webhook-svc
      namespace: default
      port: 9443
      path: /mutate--v1-pod
  sideEffects: NoneOnDryRun
  failurePolicy: Fail
  namespaceSelector:
    matchExpressions:
    - key: kubernetes.io/metadata.name
      operator: In
      values:
      - crypto-tracker
  objectSelector:
    matchLabels:
      sparkoperator.k8s.io/launched-by-spark-operator: "true"
  rules:
  - apiGroups: [""]
    apiVersions: ["v1"]
    resources: ["pods"]
    operations: ["CREATE"]
  timeoutSeconds: 10
- name: mutate-sparkoperator-k8s-io-v1beta2-sparkapplication.sparkoperator.k8s.io
  admissionReviewVersions: ["v1"]
  clientConfig:
    service:
      name: release-name-spark-operator-webhook-svc
      namespace: default
      port: 9443
      path: /mutate-sparkoperator-k8s-io-v1beta2-sparkapplication
  sideEffects: NoneOnDryRun
  failurePolicy: Fail
  namespaceSelector:
    matchExpressions:
    - key: kubernetes.io/metadata.name
      operator: In
      values:
      - crypto-tracker
  rules:
  - apiGroups: ["sparkoperator.k8s.io"]
    apiVersions: ["v1beta2"]
    resources: ["sparkapplications"]
    operations: ["CREATE", "UPDATE"]
  timeoutSeconds: 10
- name: mutate-sparkoperator-k8s-io-v1beta2-scheduledsparkapplication.sparkoperator.k8s.io
  admissionReviewVersions: ["v1"]
  clientConfig:
    service:
      name: release-name-spark-operator-webhook-svc
      namespace: default
      port: 9443
      path: /mutate-sparkoperator-k8s-io-v1beta2-scheduledsparkapplication
  sideEffects: NoneOnDryRun
  failurePolicy: Fail
  namespaceSelector:
    matchExpressions:
    - key: kubernetes.io/metadata.name
      operator: In
      values:
      - crypto-tracker
  rules:
  - apiGroups: ["sparkoperator.k8s.io"]
    apiVersions: ["v1beta2"]
    resources: ["scheduledsparkapplications"]
    operations: ["CREATE", "UPDATE"]
  timeoutSeconds: 10
---
# Source: crypto-tracker/charts/spark-operator/templates/webhook/validatingwebhookconfiguration.yaml
apiVersion: admissionregistration.k8s.io/v1
kind: ValidatingWebhookConfiguration
metadata:
  name: release-name-spark-operator-webhook
  labels:
    helm.sh/chart: spark-operator-2.0.2
    app.kubernetes.io/name: spark-operator
    app.kubernetes.io/instance: release-name
    app.kubernetes.io/version: "2.0.2"
    app.kubernetes.io/managed-by: Helm
    app.kubernetes.io/component: webhook
webhooks:
- name: validate-sparkoperator-k8s-io-v1beta2-sparkapplication.sparkoperator.k8s.io
  admissionReviewVersions: ["v1"]
  clientConfig:
    service:
      name: release-name-spark-operator-webhook-svc
      namespace: default
      port: 9443
      path: /validate-sparkoperator-k8s-io-v1beta2-sparkapplication
  sideEffects: NoneOnDryRun
  failurePolicy: Fail
  namespaceSelector:
    matchExpressions:
    - key: kubernetes.io/metadata.name
      operator: In
      values:
      - crypto-tracker
  rules:
  - apiGroups: ["sparkoperator.k8s.io"]
    apiVersions: ["v1beta2"]
    resources: ["sparkapplications"]
    operations: ["CREATE", "UPDATE"]
  timeoutSeconds: 10
- name: validate-sparkoperator-k8s-io-v1beta2-scheduledsparkapplication.sparkoperator.k8s.io
  admissionReviewVersions: ["v1"]
  clientConfig:
    service:
      name: release-name-spark-operator-webhook-svc
      namespace: default
      port: 9443
      path: /validate-sparkoperator-k8s-io-v1beta2-scheduledsparkapplication
  sideEffects: NoneOnDryRun
  failurePolicy: Fail
  namespaceSelector:
    matchExpressions:
    - key: kubernetes.io/metadata.name
      operator: In
      values:
      - crypto-tracker
  rules:
  - apiGroups: ["sparkoperator.k8s.io"]
    apiVersions: ["v1beta2"]
    resources: ["scheduledsparkapplications"]
    operations: ["CREATE", "UPDATE"]
  timeoutSeconds: 10
---
# Source: crypto-tracker/templates/readiness-checks.yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: readiness-check
  namespace: crypto-tracker
  annotations:
    "helm.sh/hook": post-install
    "helm.sh/hook-weight": "1"
    "helm.sh/hook-delete-policy": hook-succeeded
spec:
  template:
    spec:
      restartPolicy: OnFailure
      containers:
        - name: readiness-check
          image: curlimages/curl:latest
          command:
            - "sh"
            - "-c"
            - |
              until nc -z crypto-tracker-spark-operator-webhook-svc.crypto-tracker.svc 9443; do
                echo "Waiting for Spark webhook service...";
                sleep 3;
              done;
              until nc -z kafka-cluster-kafka-bootstrap.crypto-tracker.svc 9092; do
                echo "Waiting for Kafka cluster...";
                sleep 3;
              done;
              echo "All services are ready.";
---
# Source: crypto-tracker/templates/spark-app-deployment.yaml
apiVersion: "sparkoperator.k8s.io/v1beta2"
kind: SparkApplication
metadata:
  name: spark-app
  namespace: crypto-tracker
  annotations:
    "helm.sh/hook": post-install
    "helm.sh/hook-weight": "2"
spec:
  type: Python
  mode: cluster
  image: crypto-tracker/spark-py:latest
  imagePullPolicy: Never
  mainApplicationFile: "local:///opt/spark/work-dir/spark_app.py"
  restartPolicy:
    type: OnFailure
    onFailureRetries: 3
    onFailureRetryInterval: 5
  deps:
    jars:
      - local:///opt/spark/jars/spark-sql-kafka-0-10_2.12-3.5.3.jar
      - local:///opt/spark/jars/spark-token-provider-kafka-0-10_2.12-3.5.3.jar
      - local:///opt/spark/jars/kafka-clients-3.5.2.jar
      - local:///opt/spark/jars/commons-pool2-2.11.1.jar
  driver:
    cores: 1
    memory: 512m
    serviceAccount: crypto-tracker-spark-operator-spark
    env:
      - name: KAFKA_BROKER
        value: kafka-cluster-kafka-bootstrap:9092
      - name: KAFKA_TOPIC
        value: crypto-data
  executor:
    instances: 2
    cores: 1
    memory: 512m
    env:
      - name: KAFKA_BROKER
        value: kafka-cluster-kafka-bootstrap:9092
      - name: KAFKA_TOPIC
        value: crypto-data
